# 概述

浏览器有多个进程，其中**渲染进程**是最为熟悉的，渲染进程中的**主线程**是另一个重要的线程，有 js 代码的执行，DOM 事件处理，HTML、CSS 解析等任务，还要根据 DOM 和 CSSOM 生成对应的渲染树，布局树Layout tree，层叠信息，以及需要给合成线程的层树 Layer Tree（这个树是合成线程要光栅化处理的数据结构）、渲染指令，之后交给 **合成线程** Compositor Thread 合成操作
合成要将前面的层树再分块，把块交给 **光栅线程**进行光栅化处理，处理后的图块再交给合成线程去生成帧
帧经过 IPC 交给浏览器进程，浏览器进程会给 GPU 发送帧数据，GPU 负责处理显示

![](./浏览器渲染/浏览器渲染-1771987429826.png)

# 合成线程
合成线程和主线程是相互独立的，合成线程接收从主线程解析处理后的层树Layer Tree。页面会根据生成的层树对每一层进行单独的光栅化，也可以使用 `will-change`CSS 属性控制元素强制为一层
会优先处理视口相关的层，如果一层过大，合成线程还会对层进行分块处理，以便加快速度

## 合成线程中的事件处理

### 不可合成标记(Non-fast Scrollable Region)
绑定了事件的元素，都会被标记。标记了的元素，合成线程会等待，不会直接合成处理，要将元素事件发送给主线程去处理
不被标记的元素合成线程就会合成，不会受到影响

# 主线程
[当在浏览器地址栏输入url后都发生了什么](./当在浏览器地址栏输入url后都发生了什么.md)
上面的链接中有一部分不是主线程（渲染进程）的任务，只有从接收了网络流后，开始解析资源开始，直到合成成合成线程需要的数据为止
主线程要处理从合成线程来的标记的事件，因为只有这个线程是 JS 执行的线程

所以有两种情况会阻塞页面渲染（动画）
- 绑定事件，绑定到了根元素上，这样整个页面都会被标记，合成线程就无法合成，要等待事件完成
- 布局树的改变（重排、回流 reflow），会让主线程再走一遍渲染流程

## 让事件不影响合成的属性
```js
// passive: true

document.body.addEventListener('touchstart', event => {
    if (event.target === area) {
        event.preventDefault()
    }
}, {passive: true});
```

# 光栅线程
光栅化：将合成线程输出的数据变成屏幕上显示的像素的过程

# 事件传递
浏览器进程会响应用户的鼠标移动，触摸等事件，并且会把这些信息传递给 IPC，之后给渲染进程。渲染进程中的合成线程会去查看这些事件的标记，标记的事件会传送给主线程去做处理

