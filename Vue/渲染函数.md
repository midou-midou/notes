# 渲染函数

可以使用js来创建vue的虚拟节点（VNode或常说的VDOM），也就是常说的`h`函数

PS. 注意
渲染函数是在vue运行时中

## createVNode()、h()

`h`函数重载方法很多，只拿出了用的多的两个作为例子
```ts
// vue3
// packages/runtime-core/src/h.ts

// 一般标签
export function h<K extends keyof HTMLElementTagNameMap>(
  type: K,
  props?: (RawProps & HTMLElementEventHandler) | null,
  children?: RawChildren | RawSlots,
): VNode

// 组件
export function h<P>(
  type: Component<P>,
  props?: (RawProps & P) | null,
  children?: RawChildren | RawSlots,
): VNode
```
调用
```js
// <h1 msg="hello">
//   <span>子节点内容</span>
// </h1>

const vnode = h(
  'h1',
  { msg: 'hello' },       // 相当于 v-bind:msg="hello"
  [ h('span', '子节点内容') ]  // 子节点
)
```

h函数是createVNode()的一个别名

## 原理
原理也很简单，就是返回一个VNode类型的对象
```js
// 极度简化代码
function createVNode(
  type: VNodeTypes | ClassComponent | typeof NULL_DYNAMIC_COMPONENT,
  props: (Data & VNodeProps) | null = null,
  children: unknown = null,
): VNode {
  const vnode = {
    // ... 一堆属性
  } as VNode

  return vnode
}

```

## 使用

完整的渲染函数创建一个`VNode`的代码如下

```JavaScript
// vue2
// 这里创建了一个anchored-heading组件，组件要求有一个名为render的函数，来返回组件模版，props属性则为这个组件接收的props
Vue.component('anchored-heading', {
  render: function (createElement) {
    return createElement(
      'h' + this.level,
      [
        createElement('a', {
          attrs: {
            name: headingId,
            href: '#' + headingId
          }
        }, this.$slots.default)
      ]
    )
  },
  props: {
    level: {
      type: Number,
      required: true
    }
  }
})
```

eg2. 创建一个带有作用域插槽的子组件

```JavaScript
// vue2
render: function (createElement) {
  // `<div><child v-slot="props"><span>{{ props.text }}</span></child></div>`
  return createElement('div', [
    createElement('child', {
      // 在数据对象中传递 `scopedSlots`
      // 格式为 { name: props => VNode | Array<VNode> }
      scopedSlots: {
        default: function (props) {
          return createElement('span', props.text)
        }
      }
    })
  ])
}
```



