# 响应式原理

## 概念

何为响应式，不需要手动实现当数据变化时，页面元素显示的内容也要变化这个过程，只关注定义数据，改变数据。数据改变后的结果，比如页面渲染的改变则不需要我们手动处理，交给框架

## 思路

1. 创建普通数据肯定无法实现响应式，要创建响应式数据
    ```ts
    // ref()
    class RefImpl<T = any> {
      _value: T
      private _rawValue: T

      dep: Dep = new Dep()

      constructor(value: T) {
        this._value = value
      }

      get value() {
        this.dep.track()
        return this._value
      }

      set value(newValue) {
        const oldValue = this._rawValue
        if (hasChanged(newValue, oldValue)) {
          this._rawValue = newValue
          this._value = newValue
          this.dep.trigger()
        }
      }
    }

    // reactive()
    function createReactiveObject(
      target: Target,
    ) {
      if (!isObject(target) || isProxy(target)) {
        return target
      }
      const existingProxy = proxyMap.get(target)
      if (existingProxy) {
        return existingProxy
      }
      const proxy = new Proxy(
        target,
        targetType === TargetType.COLLECTION ? collectionHandlers : baseHandlers,
      )
      proxyMap.set(target, proxy)
      return proxy
    }
    ```
    
1. 上面是vue3的ref、reactive变量创建的简化代码，ref变量自己实现了依赖收集、依赖更新函数的执行。reactive则是使用Proxy创建了代理对象，来拦截对象属性访问等操作

## 依赖收集

### 依赖

使用到或者说要读取当前这个响应式值的地方，有可能是一个函数里（比如watchEffect、watch中的回调），有可能是页面的模板（页面的模版中使用）。这些代码运行的范围都是依赖，

### 收集

vue的运行时中，会有一个记录依赖的数据结构，比如WeakMap。WeakMap正好需要对象作为键，上面的ref和reactive都返回的是对象  
WeakMap的值，watchEffect、watch是你提供的回调，模板则为vue生成的一个能更新页面dom内容的回调。官方称为副作用函数

## 副作用执行

响应式数据更新后，收集的依赖副作用函数要全部执行（一个响应式数据可能会有多处读取他值的依赖，所以这些副作用函数都得执行）


